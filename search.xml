<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo 结合coding部署详解]]></title>
    <url>%2F2021%2F06%2F05%2FHexo%20%E7%BB%93%E5%90%88coding%E9%83%A8%E7%BD%B2%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Hexo 结合coding部署详解提交文件放置目录 部署命令hexo clean hexo generate 或者 hexo g hexo deploy 或者 hexo 参考资料[博客链接地址](&quot;https://www.jianshu.com/p/85192626faf3&quot;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[地表最详细MySQL行转列]]></title>
    <url>%2F2021%2F02%2F23%2F%E5%9C%B0%E8%A1%A8%E6%9C%80%E8%AF%A6%E7%BB%86MySQL%E8%A1%8C%E8%BD%AC%E5%88%97%2F</url>
    <content type="text"><![CDATA[地表最详细MySQL行转列业务需求需要将存储的数据实现行转列展示，所以弄了个案例来分析一波行转列，走起&rArr; 业务背景学校里面有记录每个学生的每一科成绩，每个学生选得课又不全相同，所以产生了学生科目成绩分析表。 原始数据效果图： 行转列后效果图: 数据表结构 学生表 CREATE TABLE `student` ( `stuid` VARCHAR(16) NOT NULL COMMENT &#39;学号&#39;, `stunm` VARCHAR(20) NOT NULL COMMENT &#39;学生姓名&#39;, PRIMARY KEY (`stuid`) ) COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 课程表 CREATE TABLE `courses` ( `courseno` VARCHAR(20) NOT NULL, `coursenm` VARCHAR(100) NOT NULL, PRIMARY KEY (`courseno`) ) COMMENT=&#39;课程表&#39; COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 成绩表 CREATE TABLE `score` ( `stuid` VARCHAR(16) NOT NULL, `courseno` VARCHAR(20) NOT NULL, `scores` FLOAT NULL DEFAULT NULL, PRIMARY KEY (`stuid`, `courseno`) ) COLLATE=&#39;utf8_general_ci&#39; ENGINE=InnoDB; 原始数据效果图的Sql select st.stuid, st.stunm, c.coursenm, s.scores From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno; 从这 Sql 中能清晰看出各表的关系。 知识点:MyISAM与InnoDB 的区别（9个不同点） ​ InnoDB和MyISAM是很多人在使用MySQL时最常用的两个表类型，这两个表类型各有优劣，5.7之后就不一样了。 ​ 1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在 begin和 commit之间，组成一个事务； ​ 2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； ​ 3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必 须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太 大，其他索引也都会很大。 ​ MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 ​ 也就是说：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都 是数据文件的地址指针。 ​ ​ 4. InnoDB 中不保存表的具体行数，也就是说，执行select count() from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的 读出保存好的行数即可。注意的是，当count()语句包含 where条件时，两种表的操作是一样的。 ​ 5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高； ​ PS： 5.7以后的InnoDB支持全文索引了 ​ 6. MyISAM表格可以被压缩后进行查询操作 ​ 7. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁 ​ 8. InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有 ​ 9.Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI​ Innodb：frm是表定义文件，ibd是数据文件​ Myisam：frm是表定义文件，myd是数据文件，myi是索引文件 ​ 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁.而MyISAM不支持。 ​ 如何选择： ​ 1.是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；​ 2.如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。​ 3.系统奔溃后，MyISAM恢复起来更困难，能否接受；​ 4.MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。 模拟数据准备/*学生表数据*/ Insert Into student (stuid, stunm) Values(&#39;1001&#39;, &#39;张三&#39;); Insert Into student (stuid, stunm) Values(&#39;1002&#39;, &#39;李四&#39;); Insert Into student (stuid, stunm) Values(&#39;1003&#39;, &#39;赵二&#39;); Insert Into student (stuid, stunm) Values(&#39;1004&#39;, &#39;王五&#39;); Insert Into student (stuid, stunm) Values(&#39;1005&#39;, &#39;刘青&#39;); Insert Into student (stuid, stunm) Values(&#39;1006&#39;, &#39;周明&#39;); /*课程表数据*/ Insert Into courses (courseno, coursenm) Values(&#39;C001&#39;, &#39;大学语文&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C002&#39;, &#39;新视野英语&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C003&#39;, &#39;离散数学&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C004&#39;, &#39;概率论与数理统计&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C005&#39;, &#39;线性代数&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C006&#39;, &#39;高等数学(一)&#39;); Insert Into courses (courseno, coursenm) Values(&#39;C007&#39;, &#39;道德与法治&#39;); /*成绩表数据*/ Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C001&#39;, 67); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C001&#39;, 68); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C001&#39;, 69); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C001&#39;, 70); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C001&#39;, 71); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C001&#39;, 72); Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C002&#39;, 87); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C002&#39;, 88); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C002&#39;, 89); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C002&#39;, 90); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C002&#39;, 91); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C002&#39;, 92); Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C003&#39;, 83); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C003&#39;, 84); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C003&#39;, 85); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C003&#39;, 86); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C003&#39;, 87); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C003&#39;, 88); Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C004&#39;, 88); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C004&#39;, 89); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C004&#39;, 90); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C004&#39;, 91); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C004&#39;, 92); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C004&#39;, 93); Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C005&#39;, 77); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C005&#39;, 78); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C005&#39;, 79); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C005&#39;, 80); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C005&#39;, 81); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C005&#39;, 82); Insert Into score(stuid, courseno, scores) Values(&#39;1001&#39;, &#39;C006&#39;, 77); Insert Into score(stuid, courseno, scores) Values(&#39;1002&#39;, &#39;C006&#39;, 78); Insert Into score(stuid, courseno, scores) Values(&#39;1003&#39;, &#39;C006&#39;, 79); Insert Into score(stuid, courseno, scores) Values(&#39;1004&#39;, &#39;C006&#39;, 80); Insert Into score(stuid, courseno, scores) Values(&#39;1005&#39;, &#39;C006&#39;, 81); Insert Into score(stuid, courseno, scores) Values(&#39;1006&#39;, &#39;C006&#39;, 82); 静态行转列实现Select st.stuid, st.stunm, MAX(CASE c.coursenm WHEN &#39;大学语文&#39; THEN s.scores ELSE 0 END ) &#39;大学语文&#39;, MAX(CASE c.coursenm WHEN &#39;新视野英语&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;新视野英语&#39;, MAX(CASE c.coursenm WHEN &#39;离散数学&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;离散数学&#39;, MAX(CASE c.coursenm WHEN &#39;概率论与数理统计&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;概率论与数理统计&#39;, MAX(CASE c.coursenm WHEN &#39;线性代数&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;线性代数&#39;, MAX(CASE c.coursenm WHEN &#39;高等数学(一)&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;高等数学(一)&#39;, MAX(CASE c.coursenm WHEN &#39;道德与法治&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;道德与法治&#39; From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno Group by st.stuid; 查询结果如图: 从上面语句可以看出，知道固定的列，可以使用语句来实现： MAX(CASE c.coursenm WHEN &#39;大学语文&#39; THEN s.scores ELSE 0 END ) &#39;大学语文&#39; 或者 SUM(CASE c.coursenm WHEN &#39;大学语文&#39; THEN s.scores ELSE 0 END ) &#39;大学语文&#39; 从这语句可以慢慢推出实现动态行转列的方法了，感觉来啦&dArr; 动态行转列脑子飞速转动，该怎么实现呢？？？ 首先要获取下面的语句 MAX(CASE c.coursenm WHEN &#39;大学语文&#39; THEN s.scores ELSE 0 END ) &#39;大学语文&#39;, MAX(CASE c.coursenm WHEN &#39;新视野英语&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;新视野英语&#39;, MAX(CASE c.coursenm WHEN &#39;离散数学&#39; THEN ifnull(s.scores,0) ELSE 0 END ) &#39;离散数学&#39;, 具体获取方式，见下面SQL SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, 0)) AS &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;&#39; ) ) FROM courses c; 得到的结果为： MAX(IF(c.coursenm = &#39;大学语文&#39;, s.scores, 0)) AS &#39;大学语文&#39;, MAX(IF(c.coursenm = &#39;新视野英语&#39;, s.scores, 0)) AS &#39;新视野英语&#39;, MAX(IF(c.coursenm = &#39;概率论与数理统计&#39;, s.scores, 0)) AS &#39;概率论与数理统计&#39;, MAX(IF(c.coursenm = &#39;离散数学&#39;, s.scores, 0)) AS &#39;离散数学&#39;, MAX(IF(c.coursenm = &#39;线性代数&#39;, s.scores, 0)) AS &#39;线性代数&#39;, MAX(IF(c.coursenm = &#39;道德与法治&#39;, s.scores, 0)) AS &#39;道德与法治&#39;, MAX(IF(c.coursenm = &#39;高等数学(一)&#39;, s.scores, 0)) AS &#39;高等数学(一)&#39; 动态列已经得到，在结合查询SQL得到效果会是咋样呢？？ Select st.stuid, st.stunm, ( SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, NULL)) AS &#39;, c.coursenm ) ) FROM courses c ) From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno Group by st.stuid; 等到的查询结果居然还不能满足呢，如下图： 像普通的语句查询是无法实现的啦，只能使出语句拼接的绝招啦 SET @sql = NULL; SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, 0)) AS &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;&#39; ) ) INTO @sql FROM courses c; SET @sql = CONCAT(&#39;Select st.stuid, st.stunm, &#39;, @sql, &#39; From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno Group by st.stuid&#39;); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; 不容易呀，终于得到结果： MySQL prepare语法： PREPARE statement_name FROM preparable_SQL_statement; /定义/ EXECUTE statement_name [USING @var_name [, @var_name] …]; /执行预处理语句/ {DEALLOCATE | DROP} PREPAREstatement_name /删除定义/ ; 需求又来了，假如需要查询学号为1005的成绩，效果如图： 该如何实现呢？？下面就是见证奇迹的SQL SET @sql = NULL; SET @stuid = &#39;1005&#39;; SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, 0)) AS &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;&#39; ) ) INTO @sql FROM courses c; SET @sql = CONCAT(&#39;Select st.stuid, st.stunm, &#39;, @sql, &#39; From Student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno Where st.stuid = &#39;&#39;&#39;, @stuid, &#39;&#39;&#39; Group by st.stuid&#39;); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; 直接在MySQL中操作是没问题的，需求完成了，不过又进到另外一个坑，项目是使用MyBatis，大家都知道在MyBatis中的XML文件中可以自己写SQL语句，但是这样的很显然我们没法放到XML文件中。 而且最关键的是，这里不能用 If 条件，好比我们要判断学号是否为空或者等于0再加上条件进行查询，可是这里不支持。 没错就是下面这样 SET @sql = NULL; SET @stuid = &#39;1003&#39;; SET @courseno = &#39;C002&#39;; SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, 0)) AS &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;&#39; ) ) INTO @sql FROM courses c; SET @sql = CONCAT(&#39;Select st.stuid, st.stunm, &#39;, @sql, &#39; From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno&#39;); IF @stuid is not null and @stuid != 0 then SET @sql = CONCAT(@sql, &#39; Where st.stuid = &#39;&#39;&#39;, @stuid, &#39;&#39;&#39;&#39;); END IF; SET @sql = CONCAT(@sql, &#39; Group by st.stuid&#39;); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; 对，我就是加上 if 之后人家就是不支持，就是这么任性。 只能使用存储过程啦，而且又方便项目调用，不啰嗦啦，直接上Sql DELIMITER &amp;&amp; drop procedure if exists SP_QueryData; Create Procedure SP_QueryData(IN stuid varchar(16)) READS SQL DATA BEGIN SET @sql = NULL; SET @stuid = NULL; SELECT GROUP_CONCAT(DISTINCT CONCAT( &#39;MAX(IF(c.coursenm = &#39;&#39;&#39;, c.coursenm, &#39;&#39;&#39;, s.scores, 0)) AS &#39;&#39;&#39;, c.coursenm, &#39;\&#39;&#39; ) ) INTO @sql FROM courses c; SET @sql = CONCAT(&#39;Select st.stuid, st.stunm, &#39;, @sql, &#39; From student st Left Join score s On st.stuid = s.stuid Left Join courses c On c.courseno = s.courseno&#39;); IF stuid is not null and stuid &lt;&gt; &#39;&#39; then SET @stuid = stuid; SET @sql = CONCAT(@sql, &#39; Where st.stuid = \&#39;&#39;, @stuid, &#39;\&#39;&#39;); END IF; SET @sql = CONCAT(@sql, &#39; Group by st.stuid&#39;); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; END &amp;&amp; DELIMITER ; 调用也很简单，直接用下面Sql就OK啦 CALL `SP_QueryData`(&#39;1005&#39;); 效果如图： 好啦，以上就是我这次MySQL行转列的实现过程，希望大家看完都有所收益！！！]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程池实现详解]]></title>
    <url>%2F2021%2F01%2F02%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[线程池详解线程池实现详解提交一个任务到线程池中，线程池的处理流程如下： 判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 流程图如下： 线程池的源码解读 ThreadPoolExecutor的execute()方法 public void execute(Runnable command) { if (command == null) throw new NullPointerException(); //如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列 if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) { //线程池处于运行状态并且加入队列成功 if (runState == RUNNING &amp;&amp; workQueue.offer(command)) { if (runState != RUNNING || poolSize == 0) ensureQueuedTaskHandled(command); } //线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程） else if (!addIfUnderMaximumPoolSize(command)) //创建线程失败，则采取阻塞处理的方式 reject(command); // is shutdown or saturated } } 创建线程的方法：addIfUnderCorePoolSize(Runnable firstTask) private boolean addIfUnderCorePoolSize(Runnable firstTask) { Thread t = null; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try { if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING) t = addThread(firstTask); } finally { mainLock.unlock(); } if (t == null) return false; t.start(); return true; } 重点在第七行 private Thread addThread(Runnable firstTask) { Worker w = new Worker(firstTask); Thread t = threadFactory.newThread(w); if (t != null) { w.thread = t; workers.add(w); int nt = ++poolSize; if (nt &gt; largestPoolSize) largestPoolSize = nt; } return t; } 这里将线程封装成工作线程worker，并放入工作线程组里，worker类的方法run方法： public void run() { try { Runnable task = firstTask; firstTask = null; while (task != null || (task = getTask()) != null) { runTask(task); task = null; } } finally { workerDone(this); } } 通过一个程序来观察线程池的工作原理： (1) 创建一个线程 public class ThreadPoolTest implements Runnable { @Override public void run() { try { Thread.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } } } (2) 线程池循环运行16个线程： public static void main(String[] args) { LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(5); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 60, TimeUnit.SECONDS, queue); for (int i = 0; i &lt; 16 ; i++) { threadPool.execute( new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;))); System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize()); if (queue.size() &gt; 0) { System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size()); } } threadPool.shutdown(); } (3) 执行结果： 线程池中活跃的线程数： 1 线程池中活跃的线程数： 2 线程池中活跃的线程数： 3 线程池中活跃的线程数： 4 线程池中活跃的线程数： 5 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数1 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数2 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数3 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数4 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数5 线程池中活跃的线程数： 6 ----------------队列中阻塞的线程数5 线程池中活跃的线程数： 7 ----------------队列中阻塞的线程数5 线程池中活跃的线程数： 8 ----------------队列中阻塞的线程数5 线程池中活跃的线程数： 9 ----------------队列中阻塞的线程数5 线程池中活跃的线程数： 10 ----------------队列中阻塞的线程数5 Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task Thread[Thread15,5,main] rejected from java.util.concurrent.ThreadPoolExecutor@232204a1[Running, pool size = 10, active threads = 10, queued tasks = 5, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369) at test.ThreadTest.main(ThreadTest.java:17) (4) 从结果可以观察出： 1、创建的线程池具体配置为：核心线程数量为5个；全部线程数量为10个；工作队列的长度为5。 2、我们通过queue.size()的方法来获取工作队列中的任务数。 3、运行原理： 刚开始都是在创建新的线程，达到核心线程数量5个后，新的任务进来后不再创建新的线程，而是将任务加入工作队列，任务队列到达上线5个后，新的任务又会创建新的普通线程，直到达到线程池最大的线程数量10个，后面的任务则根据配置的饱和策略来处理。我们这里没有具体配置，使用的是默认的配置AbortPolicy:直接抛出异常。 当然，为了达到我需要的效果，上述线程处理的任务都是利用休眠导致线程没有释放！！！ RejectedExecutionHandler：饱和策略 当队列和线程池都满了，说明线程池处于饱和状态，那么必须对新提交的任务采用一种特殊的策略来进行处理。这个策略默认配置是AbortPolicy，表示无法处理新的任务而抛出异常。JAVA提供了4中策略： 1、AbortPolicy：直接抛出异常 2、CallerRunsPolicy：只用调用所在的线程运行任务 3、DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 4、DiscardPolicy：不处理，丢弃掉。 我们现在用第四种策略来处理上面的程序： public static void main(String[] args) { LinkedBlockingQueue&lt;Runnable&gt; queue = new LinkedBlockingQueue&lt;Runnable&gt;(3); RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy(); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler); for (int i = 0; i &lt; 9 ; i++) { threadPool.execute( new Thread(new ThreadPoolTest(), &quot;Thread&quot;.concat(i + &quot;&quot;))); System.out.println(&quot;线程池中活跃的线程数： &quot; + threadPool.getPoolSize()); if (queue.size() &gt; 0) { System.out.println(&quot;----------------队列中阻塞的线程数&quot; + queue.size()); } } threadPool.shutdown(); } 执行结果： 线程池中活跃的线程数： 1 线程池中活跃的线程数： 2 线程池中活跃的线程数： 2 ----------------队列中阻塞的线程数1 线程池中活跃的线程数： 2 ----------------队列中阻塞的线程数2 线程池中活跃的线程数： 2 ----------------队列中阻塞的线程数3 线程池中活跃的线程数： 3 ----------------队列中阻塞的线程数3 线程池中活跃的线程数： 4 ----------------队列中阻塞的线程数3 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数3 线程池中活跃的线程数： 5 ----------------队列中阻塞的线程数3 这里采用了丢弃策略后，就没有再抛出异常，而是直接丢弃。在某些重要的场景下，可以采用记录日志或者存储到数据库中，而不应该直接丢弃。 设置策略有两种方式： 1、 RejectedExecutionHandler handler = new ThreadPoolExecutor.DiscardPolicy(); ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue,handler); 2、 ThreadPoolExecutor threadPool = new ThreadPoolExecutor(2, 5, 60, TimeUnit.SECONDS, queue); threadPool.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy()); ExecutorService中submit()和execute()的区别 在使用java.util.concurrent下关于线程池一些类的时候，相信很多人和我一样，总是分不清submit()和execute()的区别，今天从源码方面分析总结一下。 通常，我们通过Executors这个工具类提供多种方法来创建适合不同场景的线程池，这里就不一一介绍了。 例如，创建可缓存线程池，Executors.newCachedThreadPool()，源码如下： public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); } 通过上面源码可以看出，该方法返回的是一个ExecutorService接口，而这个接口继承Executor接口，Executor是最上层的，其中只包含一个execute() 方法： public interface Executor { void execute(Runnable command); } execute()方法的入参为一个Runnable，返回值为void，这时候我们已经知道了execute()方法的来源以及其定义。 接下来，我们来看看，submit()是从哪来的呢？ 通过猜测，应该是ExecutorService接口中的，果然，打开源码，看到了submit()方法： public interface ExecutorService extends Executor { ... &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); ... } 可以看出，在ExecutorService接口中，一共有以上三个sumbit()方法，入参可以为Callable，也可以为Runnable，而且方法有返回值Future； (补充说明：Callable&lt;T&gt;与Runnable类似，也是创建线程的一种方式，实现其call()方法即可，方法可以有返回值，而且方法上可以抛出异常;) 总结，从上面的源码以及讲解可以总结execute()和submit()方法的区别： 接收的参数不一样; submit()有返回值，而execute()没有; 例如，有个validation的task，希望该task执行完后告诉我它的执行结果，是成功还是失败，然后继续下面的操作。 submit()可以进行Exception处理; 例如，如果task里会抛出checked或者unchecked exception，而你又希望外面的调用者能够感知这些exception并做出及时的处理，那么就需要用到submit，通过对Future.get()进行抛出异常的捕获，然后对其进行处理。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis实现分分布式锁]]></title>
    <url>%2F2020%2F12%2F22%2FRedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[Redis实现分布式锁分布式锁一般有三种实现方式： 基于数据库乐观锁实现； 基于Redis的分布式锁； 基于ZooKeeper的分布式锁。 基于Redis分布式锁实现实例&hearts;废话不多说，直接上代码&hearts; 代码实现 首先我们要通过Maven引入Redis开源组件，在pom.xml文件加入下面的代码： &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;2.3.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; 加锁设值 /** * * @param key Redis的key * @param numOfMin key值失效时间 * @param supplier 函数式接口 存储的value * @return */ public String getTempValue(String key, int numOfMin, Supplier&lt;String&gt; supplier) { String value = getTempValue(key); if (StringUtils.isBlank(value)) { // 削峰 String mux = &quot;getTempValue&quot; + key; // 判断是否获锁成功 boolean store = redisTemplate.boundValueOps(mux).setIfAbsent(&quot;1&quot;); if(store){ // 设置这个锁的失效时间 redisTemplate.expire(mux,30,TimeUnit.SECONDS); value = supplier.get(); setSimilarData(key, value, numOfMin); // 操作完删除这个锁 redisTemplate.delete(mux); } else{ try { Thread.sleep(50); } catch (InterruptedException e) { e.printStackTrace(); } // 递归调用 value = getTempValue(key, numOfMin, supplier); } } return value; } public void setSimilarData(String key, String value, int time) { // 存储到redis并设置过期时间 redisTemplate.boundValueOps(key).set(value, time, TimeUnit.MINUTES); } 总结如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件。]]></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F12%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>悦读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陈金兴]]></title>
    <url>%2F2019%2F09%2F01%2F%E9%99%88%E9%87%91%E5%85%B4%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Theme-Sakura]]></title>
    <url>%2F2018%2F12%2F12%2FHexo-Theme-Sakura%2F</url>
    <content type="text"><![CDATA[hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\themes\Sakura\languages\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>悦读</tag>
      </tags>
  </entry>
</search>
